https://www.acmicpc.net/problem/1620

### 풀이 날짜

2025-10-02

### 문제 분석 요약

- 1번부터 N번까지 포켓몬이 이름과 함께 주어진다.
- 이후 M개의 질문이 주어지는데, 질문은 번호 → 이름 또는 이름 → 번호의 두 가지 형태로 나뉜다.
- 입력된 질문에 맞게 O(1)에 가까운 시간 안에 답을 출력해야 한다.

### 알고리즘 설계

#### 필요한 값

- 입력:
  - 첫 줄: N(포켓몬 수), M(질문 수)
  - 다음 N줄: 포켓몬 이름(번호는 1부터 자동 할당된다)
  - 다음 M줄: 질문(이름 or 번호)
- 출력:
  - 질문이 번호면, 이름 출력
  - 질문이 이름이면, 번호 출력

#### 풀이 순서

1. 딕셔너리(맵)와 리스트(배열)를 각각 생성한다.
   - name2idx 딕셔너리 → 이름을 key로, 번호를 value로 저장한다.
   - idx2name 리스트 → 번호 인덱스를 이용해 이름을 저장한다.
2. M개의 질문을 순회하면서:
   - 숫자인지 확인(isdigit 함수 이용)
     - if 숫자라면 idx2name[번호] 출력한다.
     - else 이름이라면 name2idx[이름] 출력한다.

## Python (백준 표준 입력 대응)

```python
import sys
input = sys.stdin.readline

def main():
    N, M = map(int, input().split())

    idx2name = [None] * (N + 1)
    name2idx = {}

    for i in range(1, N + 1):
        name = input().strip()
        idx2name[i] = name
        name2idx[name] = i

    out = []
    for _ in range(M):
        q = input().strip()
        if q.isdigit():  # 번호 → 이름
            out.append(idx2name[int(q)])
        else:            # 이름 → 번호
            out.append(str(name2idx[q]))
    print("\n".join(out))

if __name__ == "__main__":
    main()

```

## JavaScript (Node.js, 백준 표준 입력 대응)

```javascript
const fs = require("fs");

const input = fs.readFileSync(0, "utf8").trim().split(/\r?\n/);
let line = 0;

const [Nstr, Mstr] = input[line++].trim().split(" ");
const N = parseInt(Nstr, 10);
const M = parseInt(Mstr, 10);

const idx2name = new Array(N + 1);
const name2idx = new Map();

for (let i = 1; i <= N; i++) {
  const name = input[line++].trim();
  idx2name[i] = name;
  name2idx.set(name, i);
}

const out = [];
for (let i = 0; i < M; i++) {
  const q = input[line++].trim();
  if (/^\d+$/.test(q)) {
    out.push(idx2name[parseInt(q, 10)]);
  } else {
    out.push(String(name2idx.get(q)));
  }
}

console.log(out.join("\n"));
```

### 시간 복잡도

- O(N + M)
  - 포켓몬 N개 저장: O(N)
  - 질의 M개 처리: O(M)

### 느낀점 or 기억할 정보

- 파이썬 = 딕셔너리 / JS = 맵
- "dict 하나만으로 해결되지 않을까?" → No. dict와 list(배열) 둘 다 필요하다.
- dict에서 value로는 key를 못 찾나? → Yes. 못 찾는다. dict는 단방향 매핑이 기본이다.
- 중요한 포인트:
  - 파이썬의 dict는 key → value 조회만 O(1)로 지원한다.
  - 따라서 번호→이름 조회를 빠르게 하기 위해서는 idx2name 리스트나 별도의 역방향 dict가 필요하다.
  - key-value는 1:1로 보일 수 있지만, dict 자체는 "key 기준 해시 인덱싱"만 하기 때문에 value는 인덱싱 정보가 없다.
  - 결국 이 문제는 양방향 조회가 필요하기 때문에, 두 자료구조(name2idx, idx2name)를 모두 준비하는 것이 최적해법이다.
  - value → key를 dict로 직접 찾으려고 하면 O(N)이 걸려서 대규모 입력(N=100,000)에서는 시간 초과가 난다.
