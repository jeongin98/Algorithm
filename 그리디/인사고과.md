https://school.programmers.co.kr/learn/courses/30/lessons/152995?language=python3

### 풀이 날짜

2025-10-30

### 문제 분석 요약
한 회사에서 직원의 “근무 태도 점수(A)”와 “동료 평가 점수(B)” 두 가지로 평가를 한다.

- scores[i] = [근무 태도, 동료 평가] 형태로 주어진다.

- scores[0]은 원호(Wanho)의 점수이다.

다음 규칙이 있다.

1. 어떤 직원 X가 다른 직원 Y보다 두 점수 모두 낮으면(X < Y) → X는 인센티브를 받을 수 없다.

2. 인센티브를 받을 수 있는 직원 중에서, (A + B) 합이 높은 순으로 등수가 매겨진다.

3. 원호의 순위를 구하라. 단, 원호가 인센티브를 받지 못한다면 -1을 반환한다.

### 알고리즘 설계

#### 필요한 값

- 입력: scores: 직원들의 점수 배열, [근무 태도, 동료 평가]
- 출력: 원호의 등수. 단, 인센티브 자격이 없으면 -1

#### 풀이 순서
1. 정렬 기준 설정

- 근무태도 점수(A)를 기준으로 내림차순 정렬

- 단, A가 같으면 동료평가(B)를 오름차순으로 정렬
    → 이렇게 하면, A가 큰 사람일수록 앞에 오고,
    A가 같을 때 B가 낮은 사람은 “뒤의 사람에게 가려지지 않게” 처리할 수 있습니다.

2. 비교하면서 탈락자 걸러내기 (그리디)

- 정렬된 순서대로 보면서,
현재 사람의 B가 지금까지 본 사람의 최대 B보다 작으면
→ 이 사람은 이미 누군가에게 두 점수 모두 밀린 것이므로 탈락.

- 그렇지 않으면, maxB를 갱신.

3. 원호가 탈락했는지 판정

    - 만약 원호가 이 탈락자 그룹에 속하면 바로 -1 반환.

4. 남은 사람들 중 합계로 등수 계산

    - 탈락하지 않은 사람들만 대상으로 (A + B) 합계를 구한다.

    - 합계가 높은 순으로 정렬했을 때, 원호보다 합이 큰 사람의 수 + 1이 원호의 등수.

## Python (백준 표준 입력 대응)

```python
def solution(scores):
    wanho = scores[0]
    wanho_sum = sum(wanho)
    
    # 1. 근무 태도 내림차순, 동료평가 오름차순
    scores.sort(key=lambda x: (-x[0], x[1]))
    
    max_b = 0
    filtered = []
    
    for a, b in scores:
        # 이미 본 사람 중 B가 더 큰 사람이 있으면 탈락
        if b < max_b:
            # 만약 이게 원호면 인센티브 탈락
            if [a, b] == wanho:
                return -1
            continue
        else:
            max_b = b
            filtered.append([a, b])
    
    # 2. 남은 사람들 중에서 합 점수로 등수 계산
    filtered.sort(key=lambda x: -(x[0] + x[1]))
    
    rank = 1
    for a, b in filtered:
        if a + b > wanho_sum:
            rank += 1
        elif [a, b] == wanho:
            return rank
    
    return rank

```

## JavaScript (Node.js, 백준 표준 입력 대응)

```javascript
function solution(scores) {
  const wanho = scores[0];
  const wanhoSum = wanho[0] + wanho[1];

  // 1. 근무 태도 내림차순, 동료평가 오름차순
  scores.sort((a, b) => {
    if (a[0] === b[0]) return a[1] - b[1];
    return b[0] - a[0];
  });

  let maxB = 0;
  const filtered = [];

  for (const [a, b] of scores) {
    if (b < maxB) {
      // 원호 탈락
      if (a === wanho[0] && b === wanho[1]) return -1;
      continue;
    } else {
      maxB = b;
      filtered.push([a, b]);
    }
  }

  // 2. 남은 사람 중 합계 기준으로 등수 계산
  filtered.sort((a, b) => (b[0] + b[1]) - (a[0] + a[1]));

  let rank = 1;
  for (const [a, b] of filtered) {
    if (a + b > wanhoSum) rank++;
    else if (a === wanho[0] && b === wanho[1]) return rank;
  }
  return rank;
}

```

### 시간 복잡도

- O(N log N)

    - 직원 점수 정렬: O(N log N)

    - 탈락자 판정 및 등수 계산: O(N)

### 느낀점 or 기억할 정보
- 이중 정렬 + 그리디가 핵심
- “두 점수 모두 낮으면 탈락”이라는 조건은 결국 Pareto dominance 문제로 바꿀 수 있다.
- A 기준으로 정렬하고, B의 최대값을 관리하면 O(N)에 탈락자 판별이 가능하다.
- 단순 비교 문제처럼 보여도, 실제로는 O(N²) 완전탐색을 O(N log N)으로 줄이기 위한 정렬 설계 통찰을 요구하는 문제
    → 이 과정을 한 번의 순회로 해결하는 게 핵심이다.
    즉, 완전탐색 없이 “모든 직원 간 비교 결과”를 정렬과 maxB 관리 한 번으로 대체하는 통찰이 필요
- 1. “A가 같을 때 B를 오름차순으로 정렬하는 이유”
  2. “현재 사람의 B가 지금까지 본 최대 B보다 작으면 탈락의 이유”
    - A 내림차순 정렬  하나는 분명 A ≥ 현재 A 를 만족합니다 (정렬로 보장).
    - A가 더 큰 사람은 정렬상 모두 앞에 있기 때문에, 우리는 “B가 더 큰 사람이 존재했는가?”만 보면 충분하다.