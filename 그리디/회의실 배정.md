https://www.acmicpc.net/problem/1931

### 풀이 날짜

2025-09-26

### 문제 분석 요약

- 회의가 N개 주어진다. (시작 시간, 끝나는 시간)
- 하나의 회의실에서 겹치지 않게 회의를 배정할 때, 배정할 수 있는 회의의 최대 개수를 구하는 문제이다.
- 핵심 아이디어: "끝나는 시간이 빠른 회의부터 선택"하는 그리디 알고리즘.
- 이 문제는 대표적인 그리디 알고리즘 예시이다.

### 알고리즘 설계

#### 필요한 값

- 입력: N (회의 개수), N개의 회의 정보 (start, end)
- 출력: 최대 사용할 수 있는 회의의 개수

#### 풀이 순서

1. 모든 회의를 입력받아 (start, end) 형태로 저장한다.
2. 회의를 정렬 → end 기준 오름차순, end가 같으면 start 기준 오름차순으로 정렬한다.
3. lastEnd = 0, count = 0으로 초기화한다.
4. 정렬된 회의를 앞에서부터 순회하면서, start >= lastEnd이면 회의를 선택한다.
   - count += 1
   - lastEnd = end로 갱신
5. count 출력

## Python (백준 표준 입력 대응)

```python
import sys

def solve():
    input = sys.stdin.readline
    n = int(input())
    meetings = []
    for _ in range(n):
        s, e = map(int, input().split())
        meetings.append((s, e))

    # end 기준 오름차순, end 같으면 start 오름차순
    meetings.sort(key=lambda x: (x[1], x[0]))

    count = 0
    last_end = 0
    for s, e in meetings:
        if s >= last_end:
            count += 1
            last_end = e

    print(count)

if __name__ == "__main__":
    solve()
```

## JavaScript (Node.js, 백준 표준 입력 대응)

```javascript
// 백준: Node.js (v12~) 기준
const fs = require("fs");

function solve(input) {
  const lines = input.trim().split("\n");
  const n = Number(lines[0]);
  const meetings = [];

  for (let i = 1; i <= n; i++) {
    const [s, e] = lines[i].split(" ").map(Number);
    meetings.push([s, e]);
  }

  // end 오름차순, end 같으면 start 오름차순
  meetings.sort((a, b) => {
    if (a[1] !== b[1]) return a[1] - b[1];
    return a[0] - b[0];
  });

  let count = 0;
  let lastEnd = 0;
  for (const [s, e] of meetings) {
    if (s >= lastEnd) {
      count++;
      lastEnd = e;
    }
  }

  console.log(count);
}

const input = fs.readFileSync(0, "utf8");
solve(input);
```

### 시간 복잡도

- O(N log N)
  - 정렬 때문에

### 느낀점 or 기억할 정보

- 그리디 핵심: “끝나는 시간이 빠른 회의부터 선택하면 최적해가 보장된다.”
- 길이가 짧은 회의를 우선할 필요는 없음. → 중요한 건 “언제 끝나는가”임.
- start >= lastEnd 조건으로 겹치지 않는 회의만 고르면 된다.
