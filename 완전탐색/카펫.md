https://school.programmers.co.kr/learn/courses/30/lessons/42842

### 풀이 날짜

2025-10-14

### 문제 분석 요약

### 알고리즘 설계

#### 필요한 값

- 입력: brown (갈색 격자 수),yellow (노란색 격자 수)
- 출력: [가로, 세로] (단, 가로 ≥ 세로)

#### 풀이 순서

두 개의 식만 충족되면 된다.

1. n의 모든 약수쌍 (A, B)를 구한다. (즉, 가능한 가로와 세로 후보를 모두 찾는다.)

- 전체 격자 수 n = brown + yellow를 구한다.

2. 각 쌍에 대해 (A - 2) * (B - 2) == yellow인지 확인한다.
   → (A - 2) * (B - 2)해야하는 이유 : 테두리의 갈색이 한 줄씩 둘러싸고 있으므로, 가로와 세로 양쪽에서 각각 1칸씩(총 2칸)을 빼야 실제 노란색 내부 칸 수가 계산된다.

조건을 만족하는 (A, B) 쌍이 정답이다.
(가로 ≥ 세로 순서로 반환)

## Python (백준 표준 입력 대응)

```python
# ============================================
# 🧩 문제 접근 해설
#
# 카펫은 가운데가 노란색(yellow)이고,
# 그 둘레를 갈색(brown)이 한 줄로 둘러싸고 있다.
#
# 그래서 전체 칸의 수는 다음과 같다.
# brown + yellow = return 값의 [가로 * 세로]
# ex) 10+2 = 4*3, 8+1 = 3*3, 24+24 = 48
#
# 그리고 테두리를 한 줄씩 제외하면,
# 남는 노란 부분의 크기는 다음과 같다.
# (가로 - 2) * (세로 - 2) = yellow
#
# 즉, 이 두 식을 동시에 만족하는
# (가로, 세로) 쌍을 찾는 것이 문제의 핵심이다.
#
# 접근 방식
# 1. 모든 약수 쌍 (A, B)을 찾는다.
# 2. (A - 2) * (B - 2) = yellow 식을 만족하는 쌍을 찾는다.
# ============================================

def solution(b, y):
    n = b + y # 전체 칸 수
    candidates = []

    # 1. 전체 칸 수(n)의 약수쌍 (A, B)을 찾는다.
    for i in range(1, int(n**0.5) + 1):
        if n % i == 0:
            A, B = n // i, i
            candidates.append((A, B))

    # 2. (A - 2) * (B - 2) = y 를 만족하는 쌍을 찾는다.
    for A, B in candidates:
        if (A - 2) * (B - 2) == y:
            return [A, B] if A >= B else [B, A]

    return []  # 안전장치: 조건을 만족하는 쌍이 없을 때는 빈 배열을 반환한다.

```

## JavaScript (Node.js, 백준 표준 입력 대응)

```javascript
function solution(brown, yellow) {
  const total = brown + yellow; // 전체 칸 수

  // yellow의 약수쌍을 모두 확인한다.
  for (let h = 1; h * h <= yellow; h++) {
    if (yellow % h === 0) {
      const w = yellow / h;          // yellow 내부의 가로
      const W = w + 2;               // 테두리 갈색 한 줄씩 더한 전체 가로
      const H = h + 2;               // 테두리 갈색 한 줄씩 더한 전체 세로

      // 전체 칸 수가 일치하면 정답이다.
      if (W * H === total) {
        return [W, H]; // 문제 조건상 W ≥ H
      }
    }
  }

  return []; // 안전장치: 조건을 만족하는 경우가 없을 때
}
```

### 시간 복잡도

- O(√n)
  - 약수 탐색은 √n까지만 수행하므로.

### 느낀점 or 기억할 정보

- 이 문제는 단순히 (가로 \* 세로)만 구하는 것이 아니라, 두 개의 조건식

(가로 _ 세로) = brown + yellow  
(가로 - 2) _ (세로 - 2) = yellow

를 동시에 만족해야만 풀 수 있다. 두 식을 정확히 세우는 게 핵심 포인트다.

- Python에서는 제곱근(√n)을 표현할 때 n ** 0.5를 사용한다.
  예를 들어 int(n ** 0.5) + 1 은 √n 이하의 모든 정수를 탐색하기 위함이다.
- JavaScript에서는 같은 의미를 i \* i <= n으로 표현한다.
  i를 제곱해 n보다 작거나 같은 동안 반복하므로,
  결국 √n까지 탐색하는 것과 같다.
  또한 Math.sqrt(n)을 이용해도 같은 효과를 낼 수 있다.
- 즉, 두 언어 모두 “√n까지 약수를 탐색한다”는 점은 동일하지만,
  Python은 수학적 계산식으로, JS는 조건 비교식으로 접근한다는 차이가 있다.
- 또한, 조건에 맞는 (A, B)를 찾지 못했을 때는 return []를 사용해야 한다.
return만 쓰면 함수가 None을 반환하게 되어 프로그래머스 채점기에서 오답으로 처리되기 때문이다.
실제로 빈 리스트가 반환될 일은 거의 없지만, 함수가 항상 일정한 자료형(list)을 반환하도록 하는 안전장치 역할을 한다.