https://www.acmicpc.net/problem/2567

### 풀이 날짜

2025-10-16

### 문제 분석 요약
- 여러 장의 10×10 색종이를 붙였을 때, 검은 영역의 바깥 둘레 길이(외곽선 총 길이)를 구한다.

### 알고리즘 설계
- 핵심 아이디어: 100×100 격자에 색종이를 칠하고, 검은 칸의 4방향 이웃이 빈 칸이거나 격자 밖이면 둘레 +1을 누적한다.
- 색종이에 해당하는 칸에 True로 색칠하고, 해당칸의 네 개의 방향 이웃을 살핀다. 
    → if 마찬가지로 칠해져 있다면(True) 둘레로 카운트하지x
    → else 만약 빈 칸이거나 격자 밖이면, 둘레로 세어도 되기 때문에 둘레 카운트+1한다.

#### 필요한 값

- 입력: 
    - 첫 줄: 색종이 개수 N
    - 다음 N줄: 각 색종이의 좌측 하단 좌표 x y
- 출력: 검은 영역의 총 둘레(정수)

#### 풀이 순서
1. 격자 모델링
    - 100×100 불리언(또는 0/1) board[y][x]를 준비해 색종이 영역을 칠한다.
    - 색종이의 좌측 하단 좌표 (x, y)가 주어지면 [x, x+9] × [y, y+9]를 채운다.

2. 둘레 계산(4방향 검사)
    - 모든 board[y][x] == 1인 칸에 대해 상·하·좌·우 이웃을 확인한다.
        - if 이웃이 격자 밖이거나 board[ny][nx] == 0(빈 칸)이면 둘레 +1이다.
        - else 이웃이 검은 칸이면 내부 경계이므로 +0이이다.

## Python (백준 표준 입력 대응)

```python
import sys

input = sys.stdin.readline

N = int(input().strip())
SIZE = 100
board = [[0] * SIZE for _ in range(SIZE)]

# 색종이 칠하기: (x, y)부터 10x10 영역을 채움
for _ in range(N):
    x, y = map(int, input().split())
    for i in range(x, x + 10):
        for j in range(y, y + 10):
            if 0 <= i < SIZE and 0 <= j < SIZE:
                board[j][i] = 1  # 주의: board[y][x] 순서

dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]
perimeter = 0

# 둘레 계산: 검은 칸의 4방향을 확인
for y in range(SIZE):
    for x in range(SIZE):
        if board[y][x] == 1:
            for dx, dy in dirs:
                nx, ny = x + dx, y + dy
                # 이웃이 격자 밖이거나 빈 칸이면 외곽선 +1
                if not (0 <= nx < SIZE and 0 <= ny < SIZE) or board[ny][nx] == 0:
                    perimeter += 1

print(perimeter)
```

## JavaScript (Node.js, 백준 표준 입력 대응)

```javascript
const fs = require('fs');

const tokens = fs.readFileSync(0, 'utf8').trim().split(/\s+/).map(Number);
let idx = 0;
const N = tokens[idx++];

const SIZE = 100;
const board = Array.from({ length: SIZE }, () => Array(SIZE).fill(0));

// 색종이 칠하기
for (let k = 0; k < N; k++) {
  const x = tokens[idx++], y = tokens[idx++];
  for (let i = x; i < x + 10; i++) {
    for (let j = y; j < y + 10; j++) {
      if (0 <= i && i < SIZE && 0 <= j && j < SIZE) {
        board[j][i] = 1; // 주의: board[y][x]
      }
    }
  }
}

const dirs = [[1,0], [-1,0], [0,1], [0,-1]];
let perimeter = 0;

// 둘레 계산
for (let y = 0; y < SIZE; y++) {
  for (let x = 0; x < SIZE; x++) {
    if (board[y][x] === 1) {
      for (const [dx, dy] of dirs) {
        const nx = x + dx, ny = y + dy;
        if (!(0 <= nx && nx < SIZE && 0 <= ny && ny < SIZE) || board[ny][nx] === 0) {
          perimeter += 1;
        }
      }
    }
  }
}

console.log(perimeter);
```

### 시간 복잡도

- O(N)
    - 두 가지 합산 : O(N)+O(1)≈O(N)
    - 1) 색종이 칠하기 단계 : 색종이 N장이 있고, 각 색종이는 10×10 크기 = 100칸이다. 따라서 칠하는 데 드는 연산 수는 → O(N × 100) = O(N)
    - 2) 둘레 계산 단계 : 격자 크기는 100×100 = 10,000칸이고, 각 칸마다 상하좌우 4방향을 확인하므로 → O(100 × 100 × 4) = O(40,000) = O(1)

### 느낀점 or 기억할 정보
- 접근 방식이 생각이 안 났다.
- board[y][x] 로 접근하기 → 2차원 배열은 “행(row)”과 “열(column)” 기준이기 때문에 board[row][col] = board[y축][x축] 으로 접근해야한다.
    → 1. 수학에서 우리가 아는 좌표계 : (x, y)
    → 2. 컴퓨터 메모리에서 2차원 배열 : (y, x)