https://www.acmicpc.net/problem/14725

### 풀이 날짜

2025-10-01

### 문제 분석 요약

- 개미가 지나간 여러 먹이 경로가 주어진다.
- 각 경로는 문자열들의 나열로 표현된다.
- 이 경로들을 공통 prefix 기준으로 합쳐서 계층 구조(트리/트라이)로 표현한 뒤, 사전순으로 정렬해서 출력해야 한다.
- 출력 시 깊이에 따라 앞에 "--"를 depth만큼 붙여서 계층을 표시한다.

### 알고리즘 설계

#### 필요한 값

- 입력: N (경로 개수), 각 경로: K (토큰 수) + K개의 문자열
- 출력: 루트는 생략하고, 계층 구조를 depth에 맞게 "--"를 붙여 사전순으로 출력한 문자열

#### 풀이 순서

1. 루트 노드를 가진 빈 트리(트라이)를 만든다.

- 각 노드는 children = {} 형태로 관리 (딕셔너리/맵)한다.

2. 각 경로를 루트에서 시작해 차례대로 삽입한다.

- 해당 문자열이 현재 노드의 자식에 없으면 새 노드를 생성한다.

3. 모든 입력을 삽입한 뒤, DFS(또는 재귀)를 통해 출력한다.

- 현재 노드의 자식들을 사전순으로 정렬한다.
- 정렬된 순서대로 "--"\*depth + 이름을 출력한다.
- 자식 노드로 내려가서 depth+1로 재귀 반복.

## Python (백준 표준 입력 대응)

```python
import sys
input = sys.stdin.readline

class Node:
    __slots__ = ("children",)
    def __init__(self):
        self.children = {}  # name -> Node

def insert(root, foods):
    cur = root
    for f in foods:
        if f not in cur.children:
            cur.children[f] = Node()
        cur = cur.children[f]

def dfs(node, depth, out):
    # 자식 이름 사전순 정렬 후 출력
    for name in sorted(node.children.keys()):
        out.append("{}{}".format("--" * depth, name))
        dfs(node.children[name], depth + 1, out)

def main():
    n = int(input().strip())
    root = Node()
    for _ in range(n):
        parts = input().split()
        k = int(parts[0])
        foods = parts[1:1+k]
        insert(root, foods)
    out = []
    dfs(root, 0, out)
    print("\n".join(out))

if __name__ == "__main__":
    main()
```

## JavaScript (Node.js, 백준 표준 입력 대응)

```javascript
const fs = require("fs");

class Node {
  constructor() {
    this.children = new Map(); // name -> Node
  }
}

function insert(root, foods) {
  let cur = root;
  for (const f of foods) {
    if (!cur.children.has(f)) {
      cur.children.set(f, new Node());
    }
    cur = cur.children.get(f);
  }
}

function dfs(node, depth, out) {
  // Map의 키들을 사전순으로 정렬
  const names = Array.from(node.children.keys()).sort();
  for (const name of names) {
    out.push(`${"--".repeat(depth)}${name}`);
    dfs(node.children.get(name), depth + 1, out);
  }
}

(function main() {
  const input = fs.readFileSync(0, "utf8").trim().split(/\r?\n/);
  let idx = 0;
  const n = parseInt(input[idx++].trim(), 10);
  const root = new Node();

  for (let i = 0; i < n; i++) {
    const parts = input[idx++].trim().split(/\s+/);
    const k = parseInt(parts[0], 10);
    const foods = parts.slice(1, 1 + k);
    insert(root, foods);
  }

  const out = [];
  dfs(root, 0, out);
  console.log(out.join("\n"));
})();
```

### 시간 복잡도

- O(N \* L)
  - 트리(트라이) 구성
  - N = 경로 개수, L = 한 경로의 평균 길이

### 느낀점 or 기억할 정보

- 이 문제는 단순 정렬만으로는 풀 수 없고, 트리(트라이) 구조를 직접 구현해야 한다는 점이 핵심이다.
- 문자열 prefix를 공유하는 구조를 이해하는 것이 중요하다.
