https://school.programmers.co.kr/learn/courses/30/lessons/258712?language=python3

### 풀이 날짜

2025-10-10

### 문제 분석 요약

- 친구 목록과 선물 기록이 주어질 때, 규칙에 따라 “다음 달” 각 사람이 받게 될 선물 수를 계산하고, 그중 최댓값을 구하는 문제이다.
- 난이도는 lv1로 낮으나, 문제 해결을 위해 한 단계씩 처리해야할 부분이 많아, 다소 체감 난이도가 올라감

### 알고리즘 설계

#### 필요한 값

- 입력:
  - friends: 친구 이름 리스트 (길이 N, 모두 서로 다른 이름)
  - gifts: "보낸이 받은이" 문자열 리스트 (길이 M)
- 출력:
  - 다음 달에 가장 많이 선물을 받는 사람의 선물 개수(정수)

#### 풀이 순서

1. 이름 → 인덱스 매핑 만들기
   idx = {name: i for i, name in enumerate(friends)}

2. 카운팅 테이블 초기화

   - count[i][j] = i가 j에게 이번 달에 보낸 횟수
   - sent[i] = i가 보낸 총 횟수, recv[i] = i가 받은 총 횟수

3. 선물 기록 누적

   - 각 "a b"에 대해 ai = idx[a], bi = idx[b]
   - count[ai][bi] += 1, sent[ai] += 1, recv[bi] += 1

4. 선물 지수 계산

   - gift_index[i] = sent[i] - recv[i]

5. 다음 달 수령 수 계산

- next_received[i] = 0으로 시작
- 모든 쌍 (i, j)에 대해 (i < j만 순회)
  - a_to_b = count[i][j], b_to_a = count[j][i]
  - 만약 a_to_b > b_to_a → next_received[i] += 1
    (i가 더 많이 줬으니 다음 달엔 i가 1개 받음)
  - 반대로 b_to_a > a_to_b → next_received[j] += 1
  - 같다면 gift_index 비교: 큰 쪽에 +1, 같으면 변화 없음

6. 정답 반환
   - answer = max(next_received) (비어있을 일은 없음, N ≥ 1 가정)

## Python

```python
def solution(friends, gifts):
    """
    friends: 친구 이름 문자열 리스트 (예: ["muzi", "ryan", "frodo", "neo"])
    gifts:   "보낸이 받은이" 형태의 문자열 리스트 (예: ["muzi frodo", "ryan muzi", ...])

    반환값: 다음 달에 가장 많이 선물을 받게 되는 사람의 '받은 선물 수'의 최댓값
    """

    # 1) 이름 -> 인덱스 매핑 (행/열 접근 편의)
    idx = {name: i for i, name in enumerate(friends)}
    n = len(friends)

    # 2) 이번 달 쌍별 주고받은 횟수 테이블 및 개인별 보낸/받은 합계
    #    count[i][j] = i가 j에게 보낸 횟수
    count = [[0] * n for _ in range(n)]
    sent = [0] * n   # i가 이번 달에 보낸 총 횟수
    recv = [0] * n   # i가 이번 달에 받은 총 횟수

    for line in gifts:
        a, b = line.split()     # "a b" 형식
        ai, bi = idx[a], idx[b]
        count[ai][bi] += 1
        sent[ai] += 1
        recv[bi] += 1

    # 3) 사람별 '선물 지수' = 보낸 수 - 받은 수
    gift_index = [sent[i] - recv[i] for i in range(n)]

    # 4) 다음 달에 받게 될 선물 수 계산
    next_received = [0] * n

    # 모든 서로 다른 쌍(i, j)을 한 번씩만 비교
    for i in range(n):
        for j in range(i + 1, n):
            a_to_b = count[i][j]
            b_to_a = count[j][i]

            if a_to_b > b_to_a:
                # i가 j에게 더 많이 줬으니, 다음 달에는 j가 i에게 1개를 줌
                # => j가 주고 i가 받으므로 i의 '다음 달 받은 수' +1
                next_received[i] += 1
            elif b_to_a > a_to_b:
                # j가 i에게 더 많이 줬으니, 다음 달에는 i가 j에게 1개를 줌
                next_received[j] += 1
            else:
                # 이번 달 서로 준 횟수가 같다면 '선물 지수' 비교
                if gift_index[i] > gift_index[j]:
                    next_received[i] += 1
                elif gift_index[j] > gift_index[i]:
                    next_received[j] += 1
                else:
                    # 선물 지수도 같으면 아무도 받지 않음
                    pass

    # 5) 다음 달 가장 많이 선물을 받는 사람의 개수 반환
    return max(next_received) if next_received else 0

```

## JavaScript

```javascript
function solution(friends, gifts) {
  // 1) 이름 -> 인덱스 매핑 (빠른 인덱스 접근을 위해 해시 맵 사용)
  const idx = new Map(friends.map((name, i) => [name, i]));
  const n = friends.length;

  // 2) 쌍별 주고받은 횟수 테이블 + 개인별 보낸/받은 합계
  //    count[i][j] = i가 j에게 이번 달에 보낸 횟수
  const count = Array.from({ length: n }, () => Array(n).fill(0));
  const sent = Array(n).fill(0); // i가 이번 달에 보낸 총 횟수
  const recv = Array(n).fill(0); // i가 이번 달에 받은 총 횟수

  // 3) 선물 기록 누적
  for (const line of gifts) {
    const [a, b] = line.split(" "); // "보낸이 받은이" 형식
    const ai = idx.get(a);
    const bi = idx.get(b);
    count[ai][bi] += 1;
    sent[ai] += 1;
    recv[bi] += 1;
  }

  // 4) 사람별 선물 지수 = 보낸 수 - 받은 수
  const giftIndex = sent.map((s, i) => s - recv[i]);

  // 5) 다음 달에 받을 선물 수 계산
  const nextReceived = Array(n).fill(0);

  // 모든 서로 다른 쌍(i, j)을 한 번씩만 비교 (i < j)
  for (let i = 0; i < n; i++) {
    for (let j = i + 1; j < n; j++) {
      const aToB = count[i][j];
      const bToA = count[j][i];

      if (aToB > bToA) {
        // i가 j에게 더 많이 줬으니, 다음 달엔 i가 1개 받음
        nextReceived[i] += 1;
      } else if (bToA > aToB) {
        // j가 i에게 더 많이 줬으니, 다음 달엔 j가 1개 받음
        nextReceived[j] += 1;
      } else {
        // 이번 달 서로 준 횟수가 같으면 선물 지수 비교
        if (giftIndex[i] > giftIndex[j]) {
          nextReceived[i] += 1;
        } else if (giftIndex[j] > giftIndex[i]) {
          nextReceived[j] += 1;
        }
        // 선물 지수도 같으면 아무도 못 받음 → 변화 없음
      }
    }
  }

  // 6) 다음 달 가장 많이 선물을 받는 사람의 개수 반환
  // Math.max(...[])는 -Infinity가 되므로, 빈 배열 가드 처리
  return nextReceived.length ? Math.max(...nextReceived) : 0;
}
```

### 시간 복잡도

- 선물 기록 누적: O(M)
- 모든 친구 쌍 비교: O(N^2)
- 총합: O(M + N^2)
  - N(친구 수)이 매우 크지 않은 한 충분히 빠름.
  - 이름 인덱스 조회는 딕셔너리로 평균 O(1).

### 느낀점 or 기억할 정보

- 딕셔너리 매핑으로 이름→인덱스를 만들어 두면, 문자열 기반 탐색(list.index)을 매번 하지 않아 전체 성능이 크게 개선된다.
- 이차원 배열로 ‘쌍별’ 카운팅을 한다. → count[i][j] = i가 j에게 보낸 횟수.
