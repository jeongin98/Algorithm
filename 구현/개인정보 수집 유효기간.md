https://school.programmers.co.kr/learn/courses/30/lessons/150370

### 풀이 날짜

2025-10-28

### 문제 분석 요약
- 오늘 날짜 today, 약관 목록 terms(예: "A 6" → A는 6개월), 개인정보 목록 privacies(예: "2021.05.02 A")가 주어진다.

- 각 개인정보는 수집일로부터 해당 약관에 적힌 개월 수가 지나면 만료된다.

- 이 문제에서는 모든 달을 28일로 본다(즉, 1개월 = 28일, 1년 = 12×28일).

- 만료일이 오늘과 같거나 이전이면 파기해야 하며, 파기해야 하는 개인정보의 번호(1-based) 를 오름차순으로 반환한다.

### 알고리즘 설계

#### 필요한 값

- 입력:
    - today: 문자열 "YYYY.MM.DD"
    - terms: 문자열 배열, 각 원소 "종류 개월수" 
    - privacies: 문자열 배열, 각 원소 "YYYY.MM.DD 종류"
- 출력: 파기 대상 개인정보의 인덱스 배열(1부터 시작)

#### 풀이 순서
1. 날짜 → 절대 일수 변환 함수를 만든다.

to_days(y, m, d) = (y * 12 * 28) + ((m - 1) * 28) + d

(모든 달이 28일이므로 단순 산술로 월/년 이동이 자동 처리됨)

2. today를 파싱해 오늘의 일수를 구한다.

3. terms를 순회하여 약관종류 → 개월수 맵을 만든다. (예: { 'A': 6, 'B': 12 })

4. privacies를 앞에서부터 순회한다.

- 수집일과 약관종류를 파싱하고, 수집일 일수를 구한다.

- 만료일 = 수집일 + (개월수 × 28) 으로 계산한다.

- 만료일 ≤ 오늘이면 파기 대상으로 인덱스를 기록한다.

5. 파기 대상 인덱스 배열을 반환한다.

주의: 흔히 “만료일 - 1일”로 착각하는데, 이 문제는 만료일 본인까지 포함해서 만료일 ≤ 오늘이면 파기한다. (즉, -1일 보정 불필요)

## Python (백준 표준 입력 대응)

```python
def solution(today, terms, privacies):
    def to_days(date_str):
        y, m, d = map(int, date_str.split('.'))
        return y * 12 * 28 + (m - 1) * 28 + d

    today_days = to_days(today)

    term_map = {}
    for t in terms:
        kind, months = t.split()
        term_map[kind] = int(months)

    answer = []
    for i, p in enumerate(privacies, start=1):
        date_str, kind = p.split()
        start_days = to_days(date_str)
        expire_days = start_days + term_map[kind] * 28  # -1일 보정 없음
        if expire_days <= today_days:
            answer.append(i)
    return answer

```

## JavaScript (Node.js, 백준 표준 입력 대응)

```javascript
function solution(today, terms, privacies) {
  const toDays = (s) => {
    const [y, m, d] = s.split('.').map(Number);
    return y * 12 * 28 + (m - 1) * 28 + d;
  };

  const todayDays = toDays(today);

  const termMap = new Map();
  for (const t of terms) {
    const [kind, months] = t.split(' ');
    termMap.set(kind, Number(months));
  }

  const answer = [];
  privacies.forEach((p, idx) => {
    const [dateStr, kind] = p.split(' ');
    const startDays = toDays(dateStr);
    const expireDays = startDays + termMap.get(kind) * 28; // -1 보정 불필요
    if (expireDays <= todayDays) answer.push(idx + 1);
  });

  return answer;
}

```

### 시간 복잡도

- O(T + P)
  - 약관 파싱: O(T)
  - 개인정보 순회 및 만료 계산: O(P)
  - (각 날짜 파싱과 일수 변환은 O(1)

### 느낀점 or 기억할 정보
- 모든 달을 28일로 환산하는 순간, 월말/윤년/말일 처리 고민이 사라진다.

- 만료 판정은 “만료일 ≤ 오늘” 이 핵심이다(‘오늘 만료’도 파기).

- 구현 실수 포인트:
  - 날짜 파싱 시 앞/뒤 공백, 점(.) 분리 주의
  - 약관 맵핑 누락/오타
  - -1일 보정 불필요(이 문제 규칙에서는 바로 +months*28로 비교)