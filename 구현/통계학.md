https://www.acmicpc.net/problem/2108

###  풀이 날짜
2025-09-11

###  문제 분석 요약
- N개의 정수가 주어졌을 때, 다음 네 가지 통계값을 구하는 문제
1. 산술평균: 모든 수의 합을 N으로 나눈 값(소수점은 반올림, 음수도 절대값 기준 0.5 이상은 올림 → HALF_UP)
2. 중앙값: 오름차순 정렬했을 때 가운데 있는 값
3. 최빈값: 가장 많이 나타나는 값 (여러 개면 두 번째로 작은 값)
4. 범위: 최댓값 - 최솟값

### 알고리즘 설계
#### 필요한 값
- 입력: 정수 개수 N (1 ≤ N ≤ 500,000)
- 데이터: 정수 N개 (범위: -4000 ≤ 값 ≤ 4000)
  
#### 풀이 순서
1. 입력값 N, 정수 배열 A를 입력받기
2. 미리 배열을 정렬(sort)한다
3. 산술평균: sum(A)/N을 HALF_UP 규칙으로 반올림
중앙값: 배열을 정렬한 뒤, A[N//2] 찾아낸다.
최빈값:
  - 각 숫자의 등장 빈도를 센다.
  - 최빈 빈도를 찾는다.
  - 해당 빈도의 값을 모두 모은 뒤 정렬 → 하나면 그대로, 여러 개면 두 번째로 작은 값 선택
4. 범위: max(A) - min(A) 계산
5. 네 값을 순서대로 출력

## Python (BFS, 표준 입력 대응)
``` python
import sys
from collections import Counter
from decimal import Decimal, ROUND_HALF_UP

input = sys.stdin.readline

N = int(input())
A = [int(input()) for _ in range(N)]
A.sort()

# 1) 산술평균 (HALF_UP 반올림)
mean = int((Decimal(sum(A)) / Decimal(N)).to_integral_value(rounding=ROUND_HALF_UP))

# 2) 중앙값
median = A[N // 2]

# 3) 최빈값
freq = Counter(A)
max_freq = max(freq.values())
modes = [num for num, cnt in freq.items() if cnt == max_freq]
modes.sort()
mode = modes[0] if len(modes) == 1 else modes[1]

# 4) 범위
rng = A[-1] - A[0]

print(mean)
print(median)
print(mode)
print(rng)

```


## JavaScript (Node.js, 백준 표준 입력 대응)
``` javascript
const fs = require('fs');
const raw = fs.readFileSync(0, 'utf8').trim().split(/\s+/).map(Number);
const N = raw[0];
const A = raw.slice(1).sort((a, b) => a - b);

// HALF_UP 반올림
function roundHalfUp(x) {
  return x >= 0 ? Math.floor(x + 0.5) : Math.ceil(x - 0.5);
}

// 1) 평균
const mean = roundHalfUp(A.reduce((s, v) => s + v, 0) / N);

// 2) 중앙값
const median = A[Math.floor(N / 2)];

// 3) 최빈값 (정렬 1패스)
let maxFreq = 1, cur = 1;
let modes = [];
for (let i = 1; i < N; i++) {
  if (A[i] === A[i - 1]) {
    cur++;
  } else {
    if (cur > maxFreq) {
      maxFreq = cur;
      modes = [A[i - 1]];
    } else if (cur === maxFreq) {
      modes.push(A[i - 1]);
    }
    cur = 1;
  }
}
if (cur > maxFreq) {
  maxFreq = cur;
  modes = [A[N - 1]];
} else if (cur === maxFreq) {
  modes.push(A[N - 1]);
}

modes.sort((a, b) => a - b);
const mode = modes.length === 1 ? modes[0] : modes[1];

// 4) 범위
const range = A[N - 1] - A[0];

console.log(mean.toString());
console.log(median.toString());
console.log(mode.toString());
console.log(range.toString());

```
<img width="619" height="65" alt="image" src="https://github.com/user-attachments/assets/30a3f26b-9d4b-4b8c-aebd-4c562c87103e" />


### 시간 복잡도
- O(N log N)
  - 정렬을 했기 때문에 O(N log N)
    → 중앙값을 구하려면 오름차순 배열의 가운데 값이 필요하기 때문

### 느낀점 or 기억할 정보
- 평균 반올림 규칙: Python 내장 round()는 은행가 반올림이므로 Decimal(…, ROUND_HALF_UP)을 반드시 사용해야 한다.
- 시간복잡도 계산: N이 최대 50만이므로, 단순한 O(N^2) 구현은 불가능. 정렬 기반 O(N log N) 알고리즘이 적절하다.
