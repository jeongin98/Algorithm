https://school.programmers.co.kr/learn/courses/30/lessons/134239

### 풀이 날짜

2025-10-24

### 문제 분석 요약
이 문제는 **우박수열(콜라츠 수열)**의 각 항을 이용해 꺾은선 그래프를 만들고,
이 그래프와 x축(y=0)이 이루는 **구간 면적(정적분 결과)**을 계산하는 문제이다.

주어진 구간 [a, b]는 일반적인 수학적 의미가 아닌,
문제에서 정의한 **특수 약속(convention)**을 따른다.
즉,

- n은 우박수열이 1이 될 때까지의 단계 수(마지막 x좌표).

- [a, b]의 실제 적분 구간은 x = a부터 x = n + b까지이다.
(b가 음수일 때는 뒤에서 b번째 구간까지를 의미.)

구간의 면적은 pref[n + b] - pref[a]로 계산한다.
단, a > n + b이면 유효하지 않은 구간이므로 -1.0을 반환한다.

### 알고리즘 설계
1. 우박수열 생성
- y = [k]로 초기화
이때, y[-1]은 현재 수열의 마지막 항을 의미함
- y[-1] != 1일 동안 반복하여:
    - 짝수면 x // 2, 홀수면 x * 3 + 1을 추가

2. 구간별 면적(사다리꼴 공식) areas 계산
- 인접한 두 항 (y[i], y[i+1])의 면적은 (y[i] + y[i+1]) / 2
- 이를 areas 배열에 저장

3. 누적합(prefix sum) 계산
- pref[i] = areas[0] + areas[1] + ... + areas[i-1]

4. 각 구간별 면적 계산
- [a, b] → 끝점 = n + b
- 조건:
    - 시작점 > 끝점이면(a > n + b) → -1.0
    - 그 외 → pref[n + b] - pref[a]

#### 필요한 값

- 입력: 
    - k: 우박수열의 시작 값
    - ranges: 여러 개의 [a, b] 쌍으로 구성된 리스트
- 출력: 각 구간 [a, b]에 대한 면적(정적분 결과)을 실수(float) 리스트로 반환

#### 풀이 순서

## Python (백준 표준 입력 대응)

```python
def solution(k, ranges):
    # 1) 우박수열 생성
    y = [k]
    while y[-1] != 1:
        x = y[-1]
        y.append(x // 2 if x % 2 == 0 else x * 3 + 1)

    # 2) 인접 점 사이 면적(사다리꼴) 배열
    areas = []
    for i in range(len(y) - 1):
        areas.append((y[i] + y[i + 1]) / 2.0)

    # 3) 누적합 prefix (pref[i] = areas[0..i-1] 합)
    pref = [0.0]
    for a in areas:
        pref.append(pref[-1] + a)

    n = len(areas)  # 마지막 x 좌표 (수열 길이-1)

    # 4) 질의 처리: [a, b] → 실제 끝점은 n + b
    ans = []
    for a, b in ranges:
        end = n + b
        if a > end:
            ans.append(-1.0)
        else:
            ans.append(pref[end] - pref[a])
    return ans

```

## JavaScript (Node.js, 백준 표준 입력 대응)

```javascript
function solution(k, ranges) {
  // 1) 우박수열 생성: x축은 단계(0..n), y축은 각 단계의 값
  const y = [k];
  while (y[y.length - 1] !== 1) {
    const cur = y[y.length - 1];
    y.push(cur % 2 === 0 ? cur / 2 : cur * 3 + 1);
  }

  // 2) 인접 점 사이 면적(사다리꼴): (y[i] + y[i+1]) / 2 * (폭 1)
  const areas = [];
  for (let i = 0; i < y.length - 1; i++) {
    areas.push((y[i] + y[i + 1]) / 2);
  }

  // 3) 누적합 prefix: pref[i] = areas[0..i-1] 합, 길이 = n+1
  const pref = [0];
  for (let i = 0; i < areas.length; i++) {
    pref.push(pref[pref.length - 1] + areas[i]);
  }

  // n은 마지막 x좌표(= areas.length)
  const n = areas.length;

  // 4) 질의 [a, b] 처리 규칙:
  //    실제 끝점 = n + b  (b가 음수면 뒤에서 b칸, 0이면 끝까지)
  //    면적 = pref[end] - pref[a], 단 a > end면 -1.0
  const res = [];
  for (const [a, b] of ranges) {
    const end = n + b;
    if (a > end) {
      res.push(-1.0);
    } else {
      res.push(pref[end] - pref[a]);
    }
  }
  return res;
}

```

### 시간 복잡도

- O(n + m)
    - 우박수열 생성: O(n) 
    - 면적 계산 및 누적합 계산: O(n)
    - 구간별 면적 조회: O(m)

### 느낀점 or 기억할 정보
- [a, b]는 일반적인 수학적 구간이 아니다.
    - 실제 구간은 x = a ~ x = n + b로 계산된다.
- pref[n + b]가 항상 사용되는 이유
    - b가 음수든 0이든, 끝점은 항상 n 기준으로 이동하기 때문
    - b=0 → n까지, b=-1 → n-1까지, b=-3 → n-3까지 → 즉, x = n + b
- pref.append(pref[-1] + a)의 의미
    - pref[i] = pref[i-1] + areas[i-1]라는 누적합 정의를 코드로 표현한 것
     → pref[i] = 이전 pref + a 합이라서
     ex. pref[2] = areas[0] + areas[1] 
         pref[3] = areas[0] + areas[1] + areas[2] => 곧 pref[2] + areas[2] 이런식이니까

    - pref[-1]은 “이전까지의 합”, a는 “새로 더할 값”
        따라서 “이전까지의 합 + 현재값”을 리스트에 순차적으로 추가함

- y[-1]의 의미
    - 리스트의 마지막 원소
    - 초기에는 k를, 반복 중에는 “현재 우박수열의 마지막 항”을 의미한다.
    - (중요) 리스트에 하나만 있을 때는 y[0]과 y[-1]이 동일하다.

- 결론적으로
    - 문제는 수학보다 “약속을 코드로 정확히 구현할 수 있느냐”를 보는 구현형 문제이다.
    - pref(누적합) 개념과 n + b 규칙을 기억하면 동일 유형 문제도 쉽게 해결 가능하다.