https://www.acmicpc.net/problem/11286

### 풀이 날짜

2025-09-30

### 문제 분석 요약

-

### 알고리즘 설계

#### 필요한 값

- 입력: 정수 x (N번 반복) → 조건에 맞도록 결과 배열에 저장
- 출력: 결과 배열 → 0 입력 시 조건에 맞는 값 (배열 없으면 0 출력)

#### 풀이 순서

1. 빈 힙(hq)을 준비한다.
2. n개의 정수 입력을 순차적으로 읽는다.
   - if x = 0 → heapq.heappop(hq)[1] 으로 출력 (없으면 0 출력)
   - if x ≠ 0 → 튜플 (절댓값,입력값 x) 저장
3. 결과 출력

## Python (백준 표준 입력 대응)

```python
import sys
import heapq

input = sys.stdin.readline

n = int(input())
hq = []
result_lines = [] # 결과는 문자열 형식으로 저장

for _ in range(n):
    x = int(input())
    if x == 0:
        if hq:
            # 튜플로 저장했으므로 [1]만 규칙대로 pop
            result_lines.append(str(heapq.heappop(hq)[1]))
        else:
            result_lines.append("0")
    else:
        heapq.heappush(hq, (abs(x), x)) # 튜플(절댓값, 실제값)으로 저장

sys.stdout.write("\n".join(result_lines))
```

## JavaScript (Node.js, 백준 표준 입력 대응)

```javascript
// 커스텀 비교 기반의 이진 힙 구현: 우선순위는 |a| < |b|, 같으면 a < b

const fs = require("fs");
const input = fs.readFileSync(0, "utf8").trim().split(/\s+/).map(Number);

class MinHeap {
  constructor(cmp) {
    this.a = [];
    this.cmp = cmp; // cmp(x, y) === true 이면 x가 y보다 우선
  }
  size() {
    return this.a.length;
  }
  isEmpty() {
    return this.a.length === 0;
  }
  peek() {
    return this.a[0];
  }
  push(x) {
    const a = this.a;
    a.push(x);
    let i = a.length - 1;
    while (i > 0) {
      const p = (i - 1) >> 1;
      if (this.cmp(a[i], a[p])) {
        [a[i], a[p]] = [a[p], a[i]];
        i = p;
      } else break;
    }
  }
  pop() {
    const a = this.a;
    if (a.length === 0) return undefined;
    const top = a[0];
    const last = a.pop();
    if (a.length > 0) {
      a[0] = last;
      this._siftDown(0);
    }
    return top;
  }
  _siftDown(i) {
    const a = this.a;
    const n = a.length;
    while (true) {
      const l = i * 2 + 1;
      const r = i * 2 + 2;
      let best = i;
      if (l < n && this.cmp(a[l], a[best])) best = l;
      if (r < n && this.cmp(a[r], a[best])) best = r;
      if (best === i) break;
      [a[i], a[best]] = [a[best], a[i]];
      i = best;
    }
  }
}

// 문제의 비교 규칙: |x|가 작을수록 우선, 같으면 x가 작은(음수 우선)
const cmp = (x, y) => {
  const ax = Math.abs(x),
    ay = Math.abs(y);
  if (ax !== ay) return ax < ay;
  return x < y;
};

const heap = new MinHeap(cmp);

let idx = 0;
const n = input[idx++];

let out = [];
for (let i = 0; i < n; i++) {
  const x = input[idx++];
  if (x === 0) {
    if (heap.isEmpty()) out.push("0");
    else out.push(String(heap.pop()));
  } else {
    heap.push(x);
  }
}
console.log(out.join("\n"));
```

### 시간 복잡도

- O(N log N)
  - 힙에 값을 삽입(push)하거나 꺼낼(pop) 때마다 → O(log N)
    - 힙은 완전 이진트리(Complete Binary Tree) 구조라, 트리 높이 = log N이기 때문에 O(log N)인 것임
  - 총 N번 연산을 수행하므로 O(N log N)

### 느낀점 or 기억할 정보

- Python은 heapq 내장으로 편리하지만, JS는 라이브러리 금지 환경(백준/프로그래머스 등)에서 직접 MinHeap 클래스를 구현해야 한다.
- hq = []는 그냥 리스트지만, heapq.heappush / heappop을 통해서만 접근해야 “힙 조건”이 유지된다.
- (abs(x), x) 형태로 튜플을 넣는 이유: 절댓값 우선 → 같으면 실제 값 우선 규칙을 자동으로 처리하기 위해.
- heappop이 튜플을 반환하기 때문에 [1]로 실제 값만 꺼낸다. [0]은 절댓값(우선순위용)이라 필요 없음.
- result_lines.append(str(...))로 문자열 변환하는 이유: "\n".join()은 문자열 리스트만 허용하기 때문. 출력 최적화를 위해 한 번에 sys.stdout.write로 출력한다.
- 기업 코테에서 우선순위 큐는 꽤 자주 나온다. (특히 다익스트라, 카드 합병, 스케줄링 문제) → 중급~상급 난이도 문제에서 빈출 유형
