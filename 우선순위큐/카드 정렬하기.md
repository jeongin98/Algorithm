https://www.acmicpc.net/problem/1715

### 풀이 날짜

2025-09-30

### 문제 분석 요약

- 모든 카드를 하나로 합칠 때까지 합치는 총 비용의 최솟값을 구하는 문제이다.
- 항상 가장 작은 두 묶음을 먼저 합치는 것이 최적
- 허프만 트리(Huffman Tree) 아이디어와 동일 → 두 개의 최소값을 먼저 합치는 전략
- 우선순위 큐 + 그리디 문제

### 알고리즘 설계

#### 필요한 값

- 입력: N (묶음 개수), N개의 값 x
- 출력: 모든 묶음을 합칠 때 드는 최소 총 비용

#### 풀이 순서

1. 모든 묶음 크기를 최소 힙에 넣는다.
2. 힙의 크기가 2 이상인 동안 반복:
   - 가장 작은 값 x, 그다음 작은 값 y를 pop.
   - 합치는 비용 cost = x + y를 누적합에 더한다.
   - cost를 다시 힙에 push하여 다음 후보로 사용.
3. 누적합을 출력한다.

단, 특이 케이스: N = 1이면 합칠 필요가 없으므로 비용은 0.

## Python (백준 표준 입력 대응)

```python
import sys
import heapq

def main():
    input = sys.stdin.readline
    N = int(input().strip())
    hq = []

    for _ in range(N):
        x = int(input().strip())
        heapq.heappush(hq, x)

    if N == 1:
        print(0)
        return

    total = 0
    while len(hq) > 1:
        a = heapq.heappop(hq)
        b = heapq.heappop(hq)
        cost = a + b
        total += cost
        heapq.heappush(hq, cost)

    print(total)

if __name__ == "__main__":
    main()
```

## JavaScript (Node.js, 백준 표준 입력 대응)

```javascript
// BigInt 안전 구현
// 힙 직접 구현
const fs = require("fs");

class MinHeap {
  constructor() {
    this.arr = [];
  }
  size() {
    return this.arr.length;
  }
  peek() {
    return this.arr[0];
  }
  push(val) {
    const a = this.arr;
    a.push(val);
    let i = a.length - 1;
    while (i > 0) {
      const p = (i - 1) >> 1;
      if (a[p] <= a[i]) break;
      [a[p], a[i]] = [a[i], a[p]];
      i = p;
    }
  }
  pop() {
    const a = this.arr;
    const n = a.length;
    if (n === 0) return undefined;
    if (n === 1) return a.pop();
    const top = a[0];
    a[0] = a.pop();
    let i = 0;
    while (true) {
      let l = i * 2 + 1,
        r = i * 2 + 2,
        s = i;
      if (l < a.length && a[l] < a[s]) s = l;
      if (r < a.length && a[r] < a[s]) s = r;
      if (s === i) break;
      [a[i], a[s]] = [a[s], a[i]];
      i = s;
    }
    return top;
  }
}

(function solve() {
  const input = fs.readFileSync(0, "utf8").trim().split(/\s+/);
  let idx = 0;
  const N = Number(input[idx++]);
  const heap = new MinHeap();

  for (let i = 0; i < N; i++) {
    // BigInt로 저장
    heap.push(BigInt(input[idx++]));
  }

  if (N === 1) {
    console.log("0");
    return;
  }

  let total = 0n;
  while (heap.size() > 1) {
    const a = heap.pop();
    const b = heap.pop();
    const cost = a + b;
    total += cost;
    heap.push(cost);
  }

  console.log(total.toString()); // BigInt → 문자열 출력
})();
```

### 시간 복잡도

- O(N log N)
  - 힙에 값을 삽입(push)하거나 꺼낼(pop) 때마다 → O(log N)
    - 힙은 완전 이진트리(Complete Binary Tree) 구조라, 트리 높이 = log N이기 때문에 O(log N)인 것임
  - 총 N번 연산을 수행하므로 O(N log N)

### 느낀점 or 기억할 정보

- 우선순위 큐 + 그리디 문제
  - 우선순위 큐(힙) 전형 문제. **“항상 두 개의 최소를 먼저 합친다”**는 그리디가 핵심이며
  - 허프만 트리(Huffman Tree) 아이디어와 동일한 문제다.(1715번 문제는 사실상 허프만 트리의 응용 문제) → 두 개의 최소값을 먼저 합치는 전략
