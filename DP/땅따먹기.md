https://www.acmicpc.net/problem/14725

### 풀이 날짜

2025-10-21

### 문제 분석 요약
- N행 × 4열의 땅에서 각 칸에 점수가 주어진다.
- 각 행에서 하나의 칸만 선택할 수 있고, 연속된 두 행에서는 같은 열을 선택할 수 없다.
- 최종적으로 얻을 수 있는 점수의 최댓값을 구하는 문제.

### 알고리즘 설계
- 그리디 x, DP O
    → 단순히 매 행마다 큰 값을 고르는 그리디 방식은 전체 최적해를 보장하지 않음.
    → 이전 선택이 다음 선택의 제약에 영향을 주기 때문에 DP(동적 프로그래밍) 문제로 분류된다. 
- 점화식은 다음과 같다
 dp[i][j] = land[i][j] + max(dp[i-1][k] for k in range(4) if k != j)

#### 필요한 값

- 입력: land → N행 × 4열의 2차원 리스트 (각 칸의 점수)
- 출력: 최종으로 밟을 수 있는 칸들의 점수의 최댓값 (정수)

#### 풀이 순서

방법은 2가지 모두 가능하다.
1️⃣ 메모리 효율(인플레이스) 버전
- 1번 방법이 가능한 이유는, 문제에서 "4개의 열만 있다”는 조건 때문이다.
- DP를 사용하는 2번 방법은 범용적인 문제 해결 방식이다.

## Python 

```python
def solution(land):
    n = len(land)
    for i in range(1, n):
        a0, a1, a2, a3 = land[i-1]
        land[i][0] += max(a1, a2, a3)
        land[i][1] += max(a0, a2, a3)
        land[i][2] += max(a0, a1, a3)
        land[i][3] += max(a0, a1, a2)
    return max(land[-1])

```

## JavaScript 

```javascript
function solution(land) {
  const n = land.length;

  for (let i = 1; i < n; i++) {
    const [a0, a1, a2, a3] = land[i - 1]; // 이전 행 백업
    land[i][0] += Math.max(a1, a2, a3);
    land[i][1] += Math.max(a0, a2, a3);
    land[i][2] += Math.max(a0, a1, a3);
    land[i][3] += Math.max(a0, a1, a2);
  }

  return Math.max(...land[n - 1]);
}

```

2️⃣ DP 배열을 사용하는 기본 버전 — 범용적 구조
## Python 

```python
def solution(land):
    n = len(land)
    dp = [[0] * 4 for _ in range(n)]
    dp[0] = land[0][:]  # 첫 행은 그대로 복사

    for i in range(1, n):
        for j in range(4):
            dp[i][j] = land[i][j] + max(dp[i-1][k] for k in range(4) if k != j)

    return max(dp[-1])

```

## JavaScript 

```javascript
function solution(land) {
  const n = land.length;
  const dp = Array.from({ length: n }, () => Array(4).fill(0));

  dp[0] = [...land[0]]; // 첫 행 복사

  for (let i = 1; i < n; i++) {
    for (let j = 0; j < 4; j++) {
      dp[i][j] = land[i][j] + Math.max(
        ...dp[i - 1].filter((_, k) => k !== j)
      );
    }
  }

  return Math.max(...dp[n - 1]);
}

```

### 시간 복잡도

- O(N)
    - 바깥 for문 : i는 1부터 n-1까지, 즉 (n-1)회 ≈ n회 반복 → O(N)
    - 안쪽 for문은 j는 0~3까지, 즉 4회 반복 , 내부 max 계산은 k는 0~3까지, 단 하나 제외하므로 3회 연산
    - 고정된 상수(12)번이라서 → O(1)

### 느낀점 or 기억할 정보
- 처음엔 그리디로 풀 수 있을 것 같았지만,
“현재의 최선 선택이 미래의 최선으로 이어지지 않는다”는 점 때문에 그리디는 실패함.
(다음 행에서 같은 열을 밟을 수 없기 때문에 과거의 선택이 미래에 제약을 줌.)
→ 따라서 DP 접근이 필수.
- dp[0] = land[0][:]는 단순 복사가 아니라
원본 리스트의 참조를 끊는 “값 복사” 이다.
dp[0] = land[0]으로 하면 land가 같이 바뀌므로 주의.
- 자바스크립트의 filter((_, k) => k !== j)의 (_, k)는 (value, index)의 두 번째 인자를 사용한다는 의미.
_는 “이 값은 안 쓸 거야”라는 관례적인 변수명이며, k는 인덱스(열 번호)를 나타냄.
- const [a0, a1, a2, a3] = land[i - 1];
→ 이전 행 [land[i-1][0], land[i-1][1], land[i-1][2], land[i-1][3]]을
구조 분해 할당으로 한 번에 변수로 꺼내오는 문법.
- 이 문제는 “4열 고정”이라서 인플레이스 버전이 가능하지만,
열의 수가 달라진다면 일반 DP 배열 버전이 필요함.