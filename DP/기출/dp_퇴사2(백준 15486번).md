https://www.acmicpc.net/problem/15486

###  풀이 날짜
2025-09-15

###  문제 분석 요약
- N일 동안 상담 일정이 주어질 때, N일 이내에 끝나는 상담들만 선택하여 얻을 수 있는 최대 수익을 구한다.
- 각 날 i(1-indexed)에서 상담을 시작하면 Ti일이 걸리고, 끝나면 Pi의 수익을 얻는다.
- 상담은 겹치게 진행할 수 없다(동시에 두 개 이상 불가)
- 목표: N일을 넘기지 않고 얻는 수익의 최댓값을 구한다.

### 알고리즘 설계
#### 필요한 값
- 입력 정수: N
- 일정 배열: T[1..N], P[1..N]
- T[i]: i일에 시작하면 걸리는 기간
- P[i]: 해당 상담을 마쳤을 때 얻는 수익
- DP 배열: dp[0..N+1]
- 의미: dp[i] = i일(시점 i에 도달)까지 얻을 수 있는 최대 수익
(i는 “오늘 시작 전 시점”으로 이해하면 됨. 마지막 날 다음 시점 N+1까지 포함)

#### 풀이 순서
1. N, 그리고 각 i=1..N에 대해 (T[i], P[i])를 입력받고, dp를 길이 N+2로 0 초기화
2. i = 1..N에 대해 아래를 수행한다.
- 전파(쉬는 선택):
  dp[i] = max(dp[i], dp[i-1])
  (전날까지의 최댓값을 오늘 시점으로 가져와 유지)
- 상담 선택(가능할 때만):
  end = i + T[i]
  만약 end <= N + 1 이면,
  dp[end] = max(dp[end], dp[i] + P[i])
  (i일에 상담을 시작하면 end 시점에 수익이 더해져서 반영됨)
3. 루프가 끝난 뒤, 답은 max(dp) 혹은 관습적으로 dp[N+1](또는 max(dp[1..N+1]))이다.
- 구현에서는 마지막에 dp[N]를 dp[N+1]로 전파해주거나, 전체 최대를 취해도 동일.
  

## Python (표준 입력 대응)
``` python
import sys
input = sys.stdin.readline

N = int(input())
T = [0] * (N + 2)
P = [0] * (N + 2)
for i in range(1, N + 1):
    t, p = map(int, input().split())
    T[i], P[i] = t, p

dp = [0] * (N + 2)

for i in range(1, N + 1):
    # 전날까지의 최댓값을 오늘로 전파 (쉬는 선택)
    if dp[i] < dp[i - 1]:
        dp[i] = dp[i - 1]

    end = i + T[i]
    # 오늘 시작하는 상담을 할 수 있으면, 끝나는 날로 점프 갱신
    if end <= N + 1:
        if dp[end] < dp[i] + P[i]:
            dp[end] = dp[i] + P[i]

print(max(dp))


```


## JavaScript (Node.js, 백준 표준 입력 대응)
``` javascript
// 백준 제출용
const fs = require('fs');
const arr = fs.readFileSync(0, 'utf8').trim().split(/\s+/).map(Number);

let idx = 0;
const N = arr[idx++];

const T = new Array(N + 2).fill(0);
const P = new Array(N + 2).fill(0);
for (let i = 1; i <= N; i++) {
  T[i] = arr[idx++];
  P[i] = arr[idx++];
}

const dp = new Array(N + 2).fill(0);

for (let i = 1; i <= N; i++) {
  // 전날 최댓값 전파
  if (dp[i] < dp[i - 1]) dp[i] = dp[i - 1];

  const end = i + T[i];
  if (end <= N + 1) {
    const cand = dp[i] + P[i];
    if (dp[end] < cand) dp[end] = cand;
  }
}

// dp[N+1]까지 고려
let ans = 0;
for (let i = 1; i <= N + 1; i++) if (dp[i] > ans) ans = dp[i];
console.log(ans);

```

<img width="620" height="59" alt="image" src="https://github.com/user-attachments/assets/17aab362-ebac-446e-9df3-f1bbabf5f40d" />



### 시간 복잡도
- O(N)
  - 날짜마다 전파 연산 1회 + 점프 연산 최대 1회만 수행하기 때문
  - 각 날짜별 연산 수가 상수 → 전체 연산은 N × 상수 = O(N)

### 느낀점 or 기억할 정보
- 경계 조건: end <= N+1만 유효(마지막 날에 정확히 끝나는 경우 포함할 것!)
- 정답 위치: dp[N]가 아니라 dp[N+1]까지 보는 이유는, “i일에 끝난 뒤”의 시점이기 때문이다.
- 왜 그리디가 아닌가?
  - “기간 대비 이득이 커 보이는 상담부터” 같은 국소 판단만으로는, 뒤에 더 큰 조합을 놓칠 수 있음.
  - 전역 최적을 보장하려면 dp로 시점별 최대를 누적/전파해야 한다.
