https://school.programmers.co.kr/learn/courses/30/lessons/43238

### 풀이 날짜

2025-09-23

### 문제 분석 요약

- n명의 사람이 공항 심사대를 통과해야 한다.
- 각 심사관은 주어진 times[i] 분이 걸리며, 동시에 여러 심사관이 병렬로 사람을 처리한다.
- 목표: 모든 사람이 심사를 마치는 데 걸리는 최소 시간을 구한다.
- 핵심 : T가 커질수록 처리 가능한 인원 수는 절대 줄어들지 않음(단조 증가).
  - 가능/불가능 판정을 이용한 이분 탐색 문제이다.
    - 단조성이 왜 중요한가?
    - “T분 안에 n명을 처리할 수 있는가?”라는 조건은
      - T가 작으면 False,
      - T가 충분히 크면 True.
    - 즉, False → True로 한 번만 바뀌는 구간이 존재합니다.
    - 이런 상황에서 답(최소 True가 되는 T)을 찾을 때 이진탐색이 딱 맞습니다.

### 알고리즘 설계

#### 필요한 값

- 입력: n(심사받아야 할 사람 수)
- 배열: times (각 심사관이 한 명 처리하는 데 걸리는 시간 배열)
- 이진 탐색 구간: low = 1, max(times) \* n (가장 느린 심사관만 전원 처리하는 최악 시간)
- 출력: ans (모든 사람이 심사를 마치는 데 필요한 ‘최소 시간 T')

#### 풀이 순서

1. 입력으로 n(사람 수), times(각 심사관 처리 시간 배열)를 저장한다.
2. 탐색 구간을 low = 1, high = max(times) \* n으로 설정한다.
3. while low <= high 루프를 돌며:
   - mid = (low + high) // 2 (후보 시간)
   - processed = sum(mid // t for t in times) (mid 분 안에 처리 가능한 전체 인원 수)
   - if 처리 인원 >= 목표 인원:
     - 값 저장(목표에 부합하므로)
     - high = mid + 1 (더 짧은 시간에서 가능 여부 탐색)
   - else :
     - low = mid - 1 (시간이 부족하므로 더 늘림)
4. 값 출력
   메모: 자바스크립트로 풀 때는 범위가 최대 10^18 까지 갈 수 있으니 BigInt를 사용하면 안전하다.

## Python

```python
def solution(n, times):
    left, right = 1, max(times) * n  # 최소~최대 소요 시간 범위
    ans = right

    while left <= right:
        mid = (left + right) // 2
        total = 0
        for t in times:
            total += mid // t
            if total >= n:   # 조기 종료로 미세 최적화
                break

        if total >= n:       # mid 시간 안에 n명 처리 가능 → 더 줄여본다
            ans = mid
            right = mid - 1
        else:                # 처리 불가 → 시간을 늘린다
            left = mid + 1

    return ans
```

## JavaScript (Node.js)

```javascript
// BigInt를 적용
function solution(n, times) {
  const bigTimes = times.map(BigInt);
  let left = 1n;
  let right = BigInt(Math.max(...times)) * BigInt(n);
  let ans = right;
  const need = BigInt(n);

  while (left <= right) {
    const mid = (left + right) / 2n; // 가운데 값 (정수 나눗셈)
    let total = 0n;

    for (const t of bigTimes) {
      total += mid / t;
      if (total >= need) break; // 조기 종료
    }

    if (total >= need) {
      // 가능 → 더 줄이기
      ans = mid;
      right = mid - 1n;
    } else {
      // 불가능 → 늘리기
      left = mid + 1n;
    }
  }

  return Number(ans); // 프로그래머스는 number 반환 기대
}
```

### 시간 복잡도

- O(m log(max(times) × n))
  1. 알고리즘의 핵심 루프는 이진탐색이다.
  - 각 단계에서 하는 일은:
    - mid = (low + high) // 2 계산 (O(1))
    - processed = sum(mid // t for t in times) 계산 (O(m), m은 심사관 수)
    - 즉, 한 번 판정(“mid분 안에 n명 처리 가능?”) → O(m)
  2. 이진탐색은 몇 번 도나? :
  - 탐색 구간은 1 ~ max(times) \* n.
  - 최악의 경우, max(times) = 10^9
  - 즉, 이 구간에서 이진탐색은 약 log₂(10^18)번 반복한다.(참고로, 이진탐색은 시간 복잡도가 O(log N))
  3. 전체 시간 복잡도(결론)
  - 이진탐색 한 스텝: O(m)
  - 반복 횟수: O(log(max(times) \* n))
  - 즉, 총합은 O(m log(max(times) × n))

### 느낀점 or 기억할 정보

- 왜 그리디(시뮬레이션)로 못 푸는가?
  1. **입력 크기 문제** : n이 최대 10억(1e9)이라서, 사람 한 명씩 심사대에 배치하는 방식은 **시뮬레이션 O(n log m)** → 시간 초과.
  2. **문제 요구사항 차이** : 이 문제는 최종 최소 시간만 구하면 되고, 각 사람이 어느 심사대를 거쳐 언제 끝났는지 같은 ‘과정’은 출력할 필요가 없다. 따라서 굳이 시뮬레이션을 할 필요가 없고, “가능/불가능”만 판정하는 이분 탐색이 더 적합하다.
     → 각 사람의 배치 과정을 출력해야한다면 우선순위 큐(min-heap)를 이용해 전부 시뮬레이션하는 greedy 풀이가 된다.
- 왜 이분 탐색인가?
  → “시간 T → 처리 가능 인원 수”가 단조 증가 함수라서, 가능한 최소 T를 찾는 데 이분 탐색을 적용할 수 있다.
  문제 설명에서 “20분에 심사대가 비지만 1분 기다려서 28분에 끝난다”는 건 하나의 시나리오일 뿐, 실제 풀이는 시뮬레이션이 아니라 “용량 계산”으로 처리한다.
- JS에서 BigInt를 사용하는 이유
  - Number : 정수 약 ±9 \* 10^15까지만 안전하게 표현할 수 있다. → 이 문제에선 불가능
  - BigInt : 정수 크기에 제한 없음 (메모리 한도까지 가능) → 문제에서 n의 범위인 10^18까지도 가능
    → 입국심사 문제에서는 max(times) \* n이 최대 10^18까지 갈 수 있으므로, Number로는 정밀도 오류가 날 수 있다. 이때 사용하는 게 BigInt 타입이다.
- JS에서 1n 이란?
  - 1n은 BigInt 리터럴을 의미한다.
  - 뒤에 n을 붙이면 그 수를 BigInt 타입으로 만들겠다는 뜻.
  - ex) 1n = BigInt형 정수 1
