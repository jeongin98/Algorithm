https://www.acmicpc.net/problem/1654

### 풀이 날짜

2025-09-22

### 문제 분석 요약

- N그루의 나무가 있고, 각 나무의 높이가 주어진다.
- 절단기 높이 H를 정해 모든 나무를 잘랐을 때, 잘려 나오는 목재 길이의 합이 최소 M 이상이 되도록 한다.
- 이때 조건을 만족하는 절단기 높이 H의 최댓값을 구하는 문제.
- 즉, "나무 절단 높이와 목재량 사이의 단조 관계"를 이용한 이분 탐색 문제이다.

### 알고리즘 설계

#### 필요한 값

- 입력: K(가지고 있는 랜선 개수), M(필요한 랜선 개수)
- 배열: arr[1..K] (각 랜선의 길이)
- 탐색 구간: low = 1, high = max(arr)
- 출력: ans (조건(N개 이상)을 만족하는 최대 랜선 길이)

#### 풀이 순서

1. 입력으로 N, M, 랜선 길이 배열을 저장한다.
2. 탐색 구간을 low=1, high=max(arr)로 설정한다.
3. while low <= high 루프를 돌며:
   - mid = (low + high) // 2 (후보 랜선 길이)
   - mid 길이로 잘랐을 때 랜선 개수 계산
   - if 자른 랜선 개수 >= 목표한 랜선 개수:
     - 값 저장(목표에 부합하므로)
     - low = mid + 1 (더 긴 랜선 길이 시도)
   - else :
     - high = mid - 1 (랜선이 부족하므로 더 짧게 잘라야 함)
4. 값 출력

## Python (BFS, 표준 입력 대응)

```python
import sys
input = sys.stdin.readline

K, N = map(int, input().split())
arr = [int(input()) for _ in range(K)]

low, high = 1, max(arr)  # 길이는 1 이상
ans = 0

while low <= high:
    mid = (low + high) // 2  # 후보 길이
    cnt = 0
    for x in arr:
        cnt += x // mid

    if cnt >= N:
        ans = mid            # mid 길이로 N개 이상 가능 → 더 길게 시도
        low = mid + 1
    else:
        high = mid - 1       # 부족 → 길이를 줄임

print(ans)
```

## JavaScript (Node.js, 백준 표준 입력 대응)

```javascript
// 백준 제출용
const fs = require("fs");
const data = fs.readFileSync(0, "utf8").trim().split(/\s+/).map(Number);

let i = 0;
const K = data[i++],
  N = data[i++];
const arr = new Array(K);
for (let k = 0; k < K; k++) arr[k] = data[i++];

let low = 1;
let high = Math.max(...arr);
let ans = 0;

while (low <= high) {
  const mid = Math.floor((low + high) / 2); // 후보 길이
  let cnt = 0;
  for (let x = 0; x < K; x++) cnt += Math.floor(arr[x] / mid);

  if (cnt >= N) {
    ans = mid; // 가능 → 더 길게
    low = mid + 1;
  } else {
    high = mid - 1; // 불가능 → 낮춤
  }
}

console.log(ans);
```

### 시간 복잡도

- O(K)
  - 각 단계마다 랜선 개수 K개를 전부 순회해야 하기 때문
  - 여기서 K는 입력 크기 → 다른 문제들에서의 N과 동일한 자리이다.

### 느낀점 or 기억할 정보

- 조건을 만족하는 값 중 "최대/최소”를 찾을 땐 단순 선형 탐색보다 이진 탐색이 정석이다. 단조성을 갖기 때문
- low = 1로 시작
