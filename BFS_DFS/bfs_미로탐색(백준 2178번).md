https://www.acmicpc.net/problem/2178

###  풀이 날짜
2025-09-08

###  문제 분석 요약
- N × M 크기의 미로에서 시작점(1,1)에서 도착점(N,M)까지 이동할 때 필요한 최소 칸 수를 구하는 문제

### 알고리즘 설계
#### 필요한 값
- 조건: N × M 크기의 미로가 주어짐
- 시작점: (1, 1) (좌측 상단)
- 도착점: (N, M) (우측 하단)
- 이동 가능: 상·하·좌·우 (벽이 아닌 1인 경우만 가능)
- 목표: 시작점에서 도착점까지 이동할 때 지나야 하는 최소 칸 수 출력
  
#### 풀이 순서
1. 미로의 행과 열 크기, 미로 정보 입력받기
2. 최단 거리 배열 dist의 초기화 후, 시작점 (0,0)의 거리 = 1 로 설정
3. BFS 시작
- 큐에서 좌표 (x, y) 꺼내기
- 상·하·좌·우로 이동 가능한 (nx, ny) 탐색
- 범위 안에 있고, 길(maze[nx][ny] == 1)이고, 아직 방문 안 했으면:
  - dist[nx][ny] = dist[x][y] + 1
  - 큐에 (nx, ny) 추가
4. 도착점 (N-1, M-1)에 도달하면 dist[N-1][M-1] 출력

## Python (BFS, 표준 입력 대응)
``` python
import sys
from collections import deque

def solve():
    input = sys.stdin.readline
    n, m = map(int, input().split())
    grid = [list(map(int, list(input().strip()))) for _ in range(n)]

    # 거리 배열: 0 = 미방문, 시작점은 1칸으로 시작
    dist = [[0] * m for _ in range(n)]
    q = deque()
    q.append((0, 0))
    dist[0][0] = 1  # 시작 칸도 카운트

    # 상, 하, 좌, 우
    dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]

    while q:
        x, y = q.popleft()
        if x == n - 1 and y == m - 1:
            print(dist[x][y])
            return
        for dx, dy in dirs:
            nx, ny = x + dx, y + dy
            # 범위 내 & 길(1) & 미방문
            if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == 1 and dist[nx][ny] == 0:
                dist[nx][ny] = dist[x][y] + 1
                q.append((nx, ny))

if __name__ == "__main__":
    solve()

```


## JavaScript (Node.js, 백준 표준 입력 대응)
``` javascript

const fs = require("fs");

function solve(input) {
  const lines = input.trim().split("\n");
  const [n, m] = lines[0].trim().split(" ").map(Number);
  const grid = [];
  for (let i = 1; i <= n; i++) {
    grid.push(lines[i].trim().split("").map(Number));
  }

  // 거리 배열: 0 = 미방문, 시작점은 1칸으로 시작
  const dist = Array.from({ length: n }, () => Array(m).fill(0));
  const q = [];
  let head = 0;

  q.push([0, 0]);
  dist[0][0] = 1;

  const dirs = [
    [-1, 0],
    [1, 0],
    [0, -1],
    [0, 1],
  ];

  while (head < q.length) {
    const [x, y] = q[head++];
    if (x === n - 1 && y === m - 1) {
      console.log(dist[x][y]);
      return;
    }
    for (const [dx, dy] of dirs) {
      const nx = x + dx;
      const ny = y + dy;
      if (
        0 <= nx && nx < n &&
        0 <= ny && ny < m &&
        grid[nx][ny] === 1 &&
        dist[nx][ny] === 0
      ) {
        dist[nx][ny] = dist[x][y] + 1;
        q.push([nx, ny]);
      }
    }
  }
}

solve(fs.readFileSync(0, "utf8"));
```
<img width="545" height="59" alt="image" src="https://github.com/user-attachments/assets/f9ad6c77-cafe-497b-b058-a41e8d56f446" />


### 시간 복잡도
- O(N×M)
  - 모든 칸(N×M)을 한 번씩만 방문하며 각 칸에서 4방향(상수 시간)만 확인하므로

### 느낀점 or 기억할 정보
- BFS를 쓰면 최단 거리를 자동으로 구할 수 있다는 점을 다시 확인했다.
- dist 배열이 단순 방문 여부 체크뿐 아니라, 동시에 “최단 칸 수”를 기록하는 역할을 한다는 점이 중요하다.
- 시간복잡도를 계산할 때 단순히 반복문 개수만 세는 게 아니라, 모든 칸을 최대 한 번만 방문한다는 사실에 기반해 O(N×M)으로 이해해야 한다.
