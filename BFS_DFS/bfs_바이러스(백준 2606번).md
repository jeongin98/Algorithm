https://www.acmicpc.net/problem/2606

###  풀이 날짜
2025-09-09

###  문제 분석 요약
- 1번 컴퓨터로부터 감염되는 컴퓨터 수(자기 자신 제외) 출력

### 알고리즘 설계
#### 필요한 값
- 정점 수: N
- 간선 수: M
- 그래프 저장: 인접 리스트(N+1 크기) (무방향: g[a].append(b), g[b].append(a)))
- 방문 체크: visited(N+1 크기) (불리언 True/False)
- 초기 시작점: 정점 1(1번 컴퓨터)
- 정답: infected (1을 제외하고 방문한 정점 수 출력)
  
#### 풀이 순서
1. N, M 입력받고, 인접 리스트 g를 초기화한다(무방향이라 양쪽 모두 저장)
2. 방문 여부를 저장하는 배열 초기화(크기는 N+1로)
3. BFS 시작
  - 큐에 시작 정점 1을 넣고 visited[1] = True
  - infected = 0으로 시작
  - 큐가 빌 때까지 반복하며, 큐에서 정점 u을 꺼내 인접한 정점 v에 대해
    - if 방문하지 않았으면 visited[v] = True, infected += 1, 큐에 v 추가
4. 큐가 빌 때까지 한 후, 탐색을 마치면 infected를 출력한다.(자기 자신을 제외해야하니 -1 해줘야함)


## Python (BFS, 표준 입력 대응)
``` python
import sys
from collections import deque

input = sys.stdin.readline

n = int(input())          # 컴퓨터 수
m = int(input())          # 간선 수
g = [[] for _ in range(n + 1)]
for _ in range(m):
    a, b = map(int, input().split())
    g[a].append(b)
    g[b].append(a)

visited = [False] * (n + 1)
q = deque([1])
visited[1] = True
infected = 0

while q:
    u = q.popleft()
    for v in g[u]:
        if not visited[v]:
            visited[v] = True
            infected += 1     # 1번을 제외한 새로 감염된 컴퓨터
            q.append(v)

print(infected)

```


## JavaScript (Node.js, 백준 표준 입력 대응)
``` javascript
const fs = require('fs');
const data = fs.readFileSync(0, 'utf8').trim().split(/\s+/).map(Number);

let idx = 0;
const n = data[idx++];     // 컴퓨터 수
const m = data[idx++];     // 간선 수

const g = Array.from({ length: n + 1 }, () => []);
for (let i = 0; i < m; i++) {
  const a = data[idx++], b = data[idx++];
  g[a].push(b);
  g[b].push(a);
}

const visited = Array(n + 1).fill(false);
const q = [];
let head = 0;
q.push(1);
visited[1] = true;

let infected = 0;
while (head < q.length) {
  const u = q[head++];
  for (const v of g[u]) {
    if (!visited[v]) {
      visited[v] = true;
      infected += 1;  // 1번 제외, 새로 감염
      q.push(v);
    }
  }
}

console.log(infected);
```
<img width="617" height="62" alt="image" src="https://github.com/user-attachments/assets/056f6437-4df6-42aa-85eb-cbdd4b302569" />



### 시간 복잡도
- O(N+M)
  - 정점 탐색 N번 이하
  - 간선 확인 M번 이하
  - 합쳐서: O(N + M)
    - '이하'라고 표현한 이유?
      → 여기서 “정점 탐색 N번 이하” / “간선 확인 M번 이하”라고 표현한 이유는, 실제로는 모든 노드/간선을 다 방문하지 않을 수도 있기 때문
      → 시간복잡도는 항상 “최악의 경우”를 기준으로 잡기 때문에 O(N+M)이라고 쓴 것

### 느낀점 or 기억할 정보
- 깨달은 점
  - while q로 돌리고, 1부터 넣고 시작하고, true로 일단 체크하고 시작
- **왜 DFS가 아니라 BFS로 풀었을까?**
  - BFS/DFS중 BFS로 푼 이유는 메모리 효율성 때문이 아닌, **안정성** 때문이다.
  → DFS 재귀는 최악의 경우 n=100, m=9999 같은 일자형 그래프에서 재귀 깊이가 n까지 가는데,
  → BFS는 while 반복문만 쓰니까 그런 위험이 없음
  - BFS의 문제 조건에 따라 DFS/BFS 둘 다 가능할 수도 있고, 특정 상황에서는 BFS가 필수이다.
    - 대신 **최단 거리 문제(예: 최소 간선 개수로 도착점까지 가기)**라면 반드시 BFS를 써야함
   
- **DFS/BFS 풀이 차이**
  - DFS → 재귀로 구현하기 쉽다.
  - BFS → 큐를 써야 한다. (while 반복문으로 많이 구현)

- **인접 리스트면 BFS다?** → ❌ 아님.
  - 인접 리스트(혹은 인접 행렬)는 그래프 저장 방식이고, BFS/DFS는 그래프 탐색 방식
  - **dfs/bfs의 효율성**
  → 그래서 DFS/BFS는 그래프 탐색 알고리즘 중 가장 효율적으로 꼽힌다.
  → 만약 인접 행렬을 썼다면 매번 O(N^2)이 되는데, 인접 리스트 덕분에 O(N+M)으로 줄어드는 것
    
- **파이썬과 JS에서 차이 정리 2가지**
  1. **큐를 다루는 방법**
  - Python은 deque가 있어서 그대로 쓰면 됨. 
  - JS는 기본 배열로 큐를 흉내내는데, shift() 대신 head 포인터를 쓰는 게 효율적
    ``` python
    // Python
    import sys
    from collections import deque
    q = deque([1])
    ```
    ``` js
    // JS
    const q = []; 
    q.push(1);
    ```

  2. **큐의 앞에서부터 데이터 조회 방식**
  - 파이썬에서는 popleft를 이용해서, 큐에서 실제 데이터를 빼옴
  - JS에서는 head 포인터를 이용해서 요소를 가리킬뿐, 큐에서 실제 데이터를 빼오지는 않음
    → JS의 shift대신 사용함. 시간복잡도가 O(N)이라 큼

  * slice(start,end) → 원본 배열을 건드리지 않고, 새로운 배열을 복사해서 반환
    → slice는 O(N)
    → Array.prototype.slice()도 결국 새로운 배열을 만드는 동작이라 O(N) 이다.
