https://www.acmicpc.net/problem/1806

### 풀이 날짜

2025-09-24

### 문제 분석 요약

- 길이 N의 자연수(양의 정수) 수열이 주어질 때, 합이 S 이상이 되는 연속 부분 수열 중 가장 짧은 길이를 구하는 문제이다.
- 단, 조건을 만족하는 구간이 하나도 없으면 0을 출력한다.
- 수열 원소가 양수이므로, 윈도우(구간)를 늘리면 합이 증가하고, 줄이면 감소하는 단조성이 성립
  → 슬라이딩 윈도우(= 같은 방향 투 포인터) 로 O(N)에 해결 가능하다.

### 알고리즘 설계

#### 필요한 값

- 입력: N (수열 길이), S (목표 합)
- 배열: arr[0..N-1] (자연수 수열)
- 출력: S 이상을 만족하는 최소 구간 길이 (없으면 0)

#### 풀이 순서

1. 입력으로 N, S, 배열 arr를 저장한다.
2. 포인터 및 상태를 초기화한다. (핵심은 end=0부터 시작한다는 것)
3. while True 루프를 돌며:

- if 조건 달성(부분합이 S 이상)인 경우:
  - 결과값 갱신
  - start 인덱스++
- else (조건 달성x인 경우) :
  - if 더 확장할 수 없다면 break (배열 끝 end 까지 닿았다면)
  - 아니라면, end 인덱스++

## Python (백준 표준 입력 대응)

```python
import sys
input = sys.stdin.readline

def solution():
    N, S = map(int, input().split())
    arr = list(map(int, input().split()))

    start = 0
    end = 0
    current_sum = 0
    min_length = N + 1  # 초기값: 안 나올 경우를 대비해 큰 값 설정

    while True:
        # current_sum이 S 이상이면 길이 계산 + start 이동하여 줄이기
        if current_sum >= S:
            min_length = min(min_length, end - start) # 결과 갱신
            current_sum -= arr[start]
            start += 1
        else:
            # current_sum < S 인 경우 더 늘려본다
            if end == N: # 배열 끝까지 도달했다면 반복문 종료
                break
            current_sum += arr[end]
            end += 1

    # 결과 출력
    if min_length == N + 1:
        print(0)
    else:
        print(min_length)

if __name__ == "__main__":
    solution()
```

## JavaScript (Node.js, 백준 표준 입력 대응)

```javascript
const fs = require("fs");
const input = fs
  .readFileSync("/dev/stdin")
  .toString()
  .trim()
  .split(/\s+/)
  .map(Number);

function solution(input) {
  let idx = 0;
  const N = input[idx++];
  const S = input[idx++];
  const arr = input.slice(idx, idx + N);

  let start = 0;
  let end = 0;
  let currentSum = 0;
  let minLength = N + 1;

  while (true) {
    if (currentSum >= S) {
      const length = end - start;
      if (length < minLength) {
        minLength = length;
      }
      currentSum -= arr[start];
      start += 1;
    } else {
      if (end === N) {
        break;
      }
      currentSum += arr[end];
      end += 1;
    }
  }

  if (minLength === N + 1) {
    console.log(0);
  } else {
    console.log(minLength);
  }
}

solution(input);
```

### 시간 복잡도

- O(N)
  - 각 원소는 start 또는 end가 한 번씩만 지나므로

### 느낀점 or 기억할 정보

- end는 왜 배열의 끝이 아닌, 0으로 초기화해서 시작해야할까?
  - 만약 end를 끝부터 시작한다면, start와 end를 같은 방향으로 옮기는 슬라이딩 윈도우의 단조성(합이 늘었다 줄었다 하는 예측 가능성)을 깨뜨릴 수 있기 때문이다.
- 왜 슬라이딩 윈도우로 풀 수 있을까?
  - 원소가 양수라 윈도우 크기와 합이 단조적으로 연동되어, start/end만으로 합을 조절 가능하기 때문이다.
- 왜 정렬하면 안 되는가?
  - 연속 구간 문제라 원래 순서가 의미 있다. 정렬 시 문제 자체가 변형된다.
- 부분합 vs 투 포인터 vs 슬라이딩 윈도우? 셋이 어떻게 다른지?
  - 문제 유형: 부분합 문제
  - 해결 방법: 투 포인터 기법 중 슬라이딩 윈도우 패턴 사용
    → 유형이 '부분합'일뿐, 효율적인 풀이는 투 포인터 기법 중 '슬라이딩 윈도우' 패턴 사용한 것이다.
