https://www.acmicpc.net/problem/2003

### 풀이 날짜

2025-09-24

### 문제 분석 요약

- 연속된 부분 수열의 합이 정확히 M이 되는 경우의 수를 구하는 문제

### 알고리즘 설계

#### 필요한 값

- 입력: N (배열 길이), M (목표 합)
- 배열: arr[0..N-1] (양의 정수 수열)
- 출력: 합이 M인 연속 부분 수열의 개수

#### 풀이 순서

1. 입력으로 N, M, 배열 arr를 저장한다.
2. 포인터와 상태를 초기화한다.
3. while True 루프를 돌며:
   - if 부분합 >= M:
     - 부분합이 M과 같다면 count 카운트++
       - start 인덱스++
   - else (currentSum < M):
     - if 배열 끝에 닿는다면 break
     - end 인덱스++
4. 루프 종료 후 결과 출력

## Python (백준 표준 입력 대응)

```python
import sys

def main():
    input = sys.stdin.readline
    N, M = map(int, input().split())
    A = list(map(int, input().split()))

    start = 0
    end = 0
    curr = 0
    cnt = 0

    while True:
        if curr >= M:
            if curr == M:
                cnt += 1
            curr -= A[start]
            start += 1
        else:
            if end == N:
                break
            curr += A[end]
            end += 1

    print(cnt)

if __name__ == "__main__":
    main()

```

## JavaScript (Node.js, 백준 표준 입력 대응)

```javascript
const fs = require("fs");

const data = fs.readFileSync(0, "utf8").trim().split(/\s+/).map(Number);
let i = 0;
const N = data[i++],
  M = data[i++];
const A = data.slice(i, i + N);

let start = 0;
let end = 0;
let curr = 0;
let cnt = 0;

while (true) {
  if (curr >= M) {
    if (curr === M) cnt += 1;
    curr -= A[start++];
  } else {
    if (end === N) break;
    curr += A[end++];
  }
}

console.log(cnt);
```

### 시간 복잡도

- O(N)
  - 각 원소는 start 또는 end가 한 번씩만 지나므로

### 느낀점 or 기억할 정보

- 이 문제(2003)는 부분합 문제지만, 정렬이 필요하지 않다. → “연속 구간” 유지가 핵심이다.
- 1806(부분합, 최소 길이)과 달리 이 문제는 “합 == M인 경우의 수”를 세는 문제라 답이 count 개수를 출력하면 된다.
