https://www.acmicpc.net/problem/2559

### 풀이 날짜

2025-09-25

### 문제 분석 요약

- N의 정수 수열에서, 연속된 K일의 합 중 최댓값을 구하는 문제.
- 슬라이딩 윈도우로 풀기 → “연속 구간 길이 K가 고정”되어 있으므로, 고정 길이이고 한 번의 선형 순회(O(N))만에 계산 가능

### 알고리즘 설계

#### 필요한 값

- 입력: N (수열 길이), K (연속 구간 길이)
- 배열: arr[0..N-1] (정수 수열)
- 출력: 길이 K인 모든 연속 구간 합의 '최댓값'

#### 풀이 순서

1. N,K,배열 입력받기
2. 초기 합으로 window_sum 초기화
3. 인덱스 i = K부터 N-1까지 순회하며:
   - 윈도우를 한 칸 오른쪽으로 민다:
   - windowSum = windowSum - arr[i-K] + arr[i] (포인트)
   - maxSum = max(maxSum, windowSum)로 최댓값(결과) 갱신.
4. 결과 출력

## Python (백준 표준 입력 대응)

```python
import sys

def main():
    input = sys.stdin.readline
    N, K = map(int, input().split())
    arr = list(map(int, input().split()))

    # 초기 윈도우 합
    window_sum = sum(arr[:K])
    max_sum = window_sum

    # 윈도우를 한 칸씩 오른쪽으로 밀며 갱신
    for i in range(K, N):
        window_sum += arr[i] - arr[i - K]
        if window_sum > max_sum:
            max_sum = window_sum

    print(max_sum)

if __name__ == "__main__":
    main()

```

## JavaScript (Node.js, 백준 표준 입력 대응)

```javascript
const fs = require("fs");

const input = fs.readFileSync(0, "utf8").trim().split(/\s+/).map(Number);
let idx = 0;
const N = input[idx++],
  K = input[idx++];
const arr = input.slice(idx, idx + N);

// 초기 윈도우 합
let windowSum = 0;
for (let i = 0; i < K; i++) windowSum += arr[i];
let maxSum = windowSum;

// 슬라이딩 윈도우로 갱신
for (let i = K; i < N; i++) {
  windowSum += arr[i] - arr[i - K];
  if (windowSum > maxSum) maxSum = windowSum;
}

console.log(maxSum.toString());
```

### 시간 복잡도

- O(N)
  - 첫 K개 원소의 합을 한 번만 계산 → (O(K))
  - 이후 윈도우를 한 칸씩 이동할 때:
    - 새 합 = 기존 합 - arr[i-K] + arr[i] → (O(1))
    - 이동 횟수 = N-K번
  - 총합 = O(K) + O(N-K) ≈ O(N)

### 느낀점 or 기억할 정보

- 문제에서 "고정 길이 K" → 슬라이딩 윈도우로 푸는게 가장 간단하고 빠르다!
